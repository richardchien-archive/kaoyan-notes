# 动态规划

动态规划适用于求解有大量重复子问题的情况的最优解。自顶向下的动态规划整体代码和递归相同，使用 memoiazation 来缓存已经计算过的项；自底向上的动态规划有点像递归的反向运算，动态规划的状态转移方程实际上就是递推式。

## 最长公共子序列 LCS

状态转移方程：

$$
F[i, j] =
\begin{cases}
F[i-1, j-1] + 1, & x[i] = y[i] \cr
\max\{ F[i, j-1], F[i-1, j] \}, & x[i] \ne y[i]
\end{cases}
$$

伪码：

```
def LengthOfLCS(SX, SY)
    M, N = len(SX), len(SY)
    F[0..M][0..N] = 0
    for i = 1 to M
        for j = 1 to N
            if SX[i-1] == SY[j-1]  # SX 和 SY 下标从 0 开始
                F[i][j] = F[i-1][j-1] + 1
            else
                F[i][j] = max(F[i-1][j], F[i][j-1])
    return F[M][N]
```

空间和时间复杂度都是 $O(MN)$。

空间优化到 $O(\min\{M, N\})$ 的伪码：

```
def LengthOfLCS(SX, SY)
    M, N = len(SX), len(SY)
    if M < N
        swap(SX, SY)
        swap(M, N)
    F[0..N] = 0
    for i = 1 to M
        UL = F[0]  # UL 指 upper-left，暂存左上方元素
        for j = 1 to N
            if SX[i-1] == SY[j-1]  # SX 和 SY 下标从 0 开始
                F[j] = UL + 1
            else
                UL = F[j]
                F[j] = max(F[j-1], F[j])
    return F[N]
```

## 背包问题

### 0-1 背包问题

有 $N$ 件物品和一个容量为 $V$ 的背包，第 $i$ 件物品所占空间是 $C_i$（费用），价值是 $W_i$，求将哪些物品放入背包可使总价值最大。

#### 状态转移方程

$$
F[i, v] = \max\{ F[i-1, v], F[i-1, v-C_i] + W_i \}
$$

#### 使用二维数组

```
F[0][0..V] = 0
for i = 1 to N
    for v = C[i] to V
        F[i][v] = max(F[i-1][v], F[i-1][v-C[i]] + W[i])
```

空间和时间复杂度都是 $O(VN)$。

#### 使用一维数组

由于每次内层迭代只是比较上一轮（i-1）产生的某些值，且最终只需要最后一次迭代的结果，因此可使用一维数组优化空间复杂度到 $O(V)$：

```
F[0..V] = 0
for i = 1 to N
    for v = V to C[i]
        F[v] = max(F[v], F[v-C[i]] + W[i])
```

这里 `for v = V to C[i]` 意味着每轮内层迭代是从右往左算的，因为需要使用上一轮的左侧的值 $F[i-1, v-C_i]$，从右往左可保证取到的左边的值是上一轮的结果。

#### 数组的初始化

根据问题的两种不同提法，数组的初始值不同。

第一种问法，要求背包恰好被装满。这种情况下初始值只有 `F[0]` 是 0，`F[1..V]` 为负无穷（实际中使用数字很大的负数）。

第二种问法，不要求恰好装满。这种情况下初始值设为 `F[0..V] = 0`。

可以理解为，数组的初始值就是在没有任何物品可以放入背包时的合法状态。

### 完全背包问题

有 $N$ 种物品和一个容量为 $V$ 的背包，每种物品都有无限件，第 $i$ 种物品所占空间是 $C_i$（费用），价值是 $W_i$，求将哪些物品放入背包可使总价值最大。

#### 状态转移方程

$$
F[i, v] = \max\{ F[i-1, v-kC_i] + kW_i | 0 \le kC_i \le v \}
$$

或

$$
F[i, v] = \max\{ F[i-1, v], F[i, v-C_i] + W_i \}
$$

#### 数据预处理

由于每件物品有无限件，可以先去掉所有费用相同或更高，但价值更小的物品。

#### 转化为 0-1 背包问题

将第 $i$ 种物品拆成费用为 $2^k C_i$、价值为 $2^k W_i$ 的若干件物品，其中 k 取遍满足 $2^k C_i \le V$ 的所有非负整数。

时间复杂度优化为 $O(V \sum \log{\lfloor V/C_i \rfloor})$。

#### 更快的方法

```
F[0..V] = 0
for i = 1 to N
    for v = C[i] to V
        F[v] = max(F[v], F[v-C[i]] + W[i])
```

时间复杂度为 $O(VN)$。

相比 0-1 背包问题，区别在于内层迭代的计算顺序，改为了从左往右计算，对应状态转移方程的第二种形式，需要用到当前轮（而不是 0-1 背包问题中用到的上一轮）左边的结果，即 $F[i, v-C_i]$。

### 多重背包问题

有 $N$ 种物品和一个容量为 $V$ 的背包，第 $i$ 种物品有 $M_i$ 件，所占空间是 $C_i$（费用），价值是 $W_i$，求将哪些物品放入背包可使总价值最大。

#### 状态转移方程

$$
F[i, v] = \max\{ F[i-1, v-kC_i] + kW_i | 0 \le k \le M_i \}
$$

#### 转化为 0-1 背包问题

将第 $i$ 种物品拆成费用为 $2^0 C_i, 2^1 C_i, \cdots, 2^{k-1} C_i, [M_i - (2^k-1)] C_i$ 的若干件物品，这些物品的费用总和为 $M_i C_i$。

伪码：

```
def MultiplePack(F, C, W, M)
    if M * C >= V
        CompletePack(F, C, W)
        return
    k = 1
    while k < M
        ZeroOnePack(k * C, k * W)
        M = M - k  # 不断从 M 中去除 2 的幂
        k = 2 * k
    ZeroOnePack(M * C, M * W)  # 剩余 M - (2^k - 1) 件
```

时间复杂度优化为 $O(V \sum \log{M_i})$。
