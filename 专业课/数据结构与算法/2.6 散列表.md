# 散列表

- 通过散列函数将关键码映射到桶地址
- 桶单元组织为数组
- 所有操作在平均意义上复杂度为 $O(1)$
- 装填因子：散列表中非空桶数量与桶单元总数的比值

## 散列函数

- key -> address 映射
- 需要能够快速计算（常数时间）
- 所有关键码经映射后应尽量覆盖整个地址空间
- 定义域规模 R 远大于取值域规模 M，散列冲突难以避免
- 关键码映射到各桶的概率应尽量接近 1/M（均匀随机分布）
- 聚集现象：词条集中到散列表内少数若干桶中（或附近）

### 除余法

$$hash(key) = key \mod M$$

其中，散列表长度 M 取素数；若 M 不取素数，则关键码映射到 [0, M) 的均匀度将大幅降低。

### MAD 法（Multiply-Add-Divide）

$$hash(key) = (a \times key + b) \mod M$$

其中，M 取素数，a > 0，b > 0，且 $a \mod M \ne 0$。

一定程度上解决了除余法中，连续关键码映射到的地址也连续导致的聚集问题。

### 伪随机数法

$$hash(key) = rand(key) \mod M$$

### 更多散列函数

- 数字分析法
- 平方取中法
- 折叠法
- 异或法
- ……

总而言之产生的地址越随机越均匀越好。

## 解决散列冲突

### 封闭定址/开散列

不改变映射出的地址（封闭定址），而是在产生冲突时通过散列表数组之外的结构（开散列）来存放冲突的词条。

#### 多槽位法

给每个地址分配多个槽位，发生冲突时放到空闲槽位。CPU 的组相联缓存就是这种策略。

缺点是装填因子较低，空间浪费大，且聚集现象严重时，小部分地址槽位不够，而大部分地址槽位空闲。

#### 独立链法

每个地址上，将冲突词条组织为一个链表。

相对于多槽位法更加灵活，空间浪费较少。但查找过程中发生冲突时，需要遍历整个链表，增加查找成本。

建议的装填因子上限为 0.9。

#### 公共溢出区法

在原散列表之外另设一个词典结构，将冲突词条放入其中。此公共溢出区若也实现为散列表，则可理解为递归形式的散列表。

### 开放定址/闭散列

当发生冲突时，在散列表内部寻找另一空闲地址（开放定址），使所有词条保持在散列表内部，而无需维护额外的结构（闭散列）。

#### 线性试探法

插入时，依次尝试地址 $[hash(key) + i] \mod M, i = 0, 1, 2, \cdots$，直到发现可用地址。

查找时操作相同，算出散列地址后依次比较，直到关键码相等（查找成功）或遇到空桶（查找失败）。相互冲突的关键码必属于同一查找链，但同一查找链中的关键码未必相互冲突。

删除时，为防止查找链断裂，需要将被删除的词条所在位置标记为“曾经放过词条”，称作懒惰删除法。标记为懒惰删除的桶和普通空桶一样参与插入操作，且再次插入时，懒惰删除标记无需复位（因为即使复位，后续再删除时仍需置位）。

优点是冲突词条连续，可充分利用系统缓存。缺点是会加剧聚集的趋势。

建议的装填因子上限为 0.5。

#### 平方试探法

插入时，依次尝试地址 $[hash(key) + i^2] \mod M, i = 0, 1, 2, \cdots$。

优点是降低了聚集现象。缺点是数据局部性相比线性试探法有所下降，但由于目前 I/O 页面规模已经足够大，只有在查找链极长时才会影响性能。

由于取平方，可能出现“明明存在空桶却无法抵达”的现象，解决方法是取散列表长度 M 为素数且保持装填因子小于 0.5。

#### 伪随机试探法

#### 再散列法

选取一个合适的二级散列函数，插入时依次尝试地址 $[hash(key) + i \times hash_2(key)] \mod M, i = 0, 1, 2, \cdots$。

## 散列码转换

利用某种散列码转换函数 `hashCode()` 将关键码统一转换为一个整数（散列码），然后再使用散列函数映射为散列地址。

被判等器判定为相等的词条，对应的散列码应该相等。反过来，如果两个不相等的词条散列码相同，则散列函数再好也无法消除冲突，但由于词条中是保存原关键码的，所以并不影响查找操作的正确性。

转换方法：

- 强制类型转换为整数
- 对成员对象求和
- 多项式散列码：将字符串 $x_0 x_1 \cdots x_{n-1}$ 转换为 $x_0 a^{n-1} + x_1 a^{n-2} + \cdots + x_{n-1} a^0$

## 应用

### 最大间隙

问题：设有 n 个点，将数轴分为 n+1 段，求中间 n-1 段中长度最大者。

#### 平凡算法

先对 n 个点坐标排序，然后顺序扫描返回间隙最大者。复杂度为 $O(n \log n)$。

#### 散列算法

通过一趟顺序扫描找到最左和最右的点，坐标分别记为 lo 和 hi，然后建立长度为 n 的散列表，使用散列函数

$$hash(x) = \lfloor \frac{(n-1)(x-lo)}{hi-lo} \rfloor$$

将各点插入散列表。这相当于把 n 个点的坐标压缩到 [0, n-1] 范围内。

然后顺序扫描散列表，在每个非空桶内，确定最靠左和最靠右的点（线性时间），进而可返回全局间隙最大者。

时间和空间复杂度均为 $O(n)$。

### 桶排序

见“排序”单独章节。

### 基数排序

见“排序”单独章节。
