# 线性表

## 动态数组/向量

### 特点

- 存储结构连续
- 循秩访问（随机访问）

### 基本操作

| 操作 | 描述 | 复杂度 |
| --- | --- | --- |
| `get(i)` | 随机访问第 i 个元素 | $O(1)$ |
| `put(i, e)` | 修改第 i 个元素值 | $O(1)$ |
| `insert(i, e)` | 插入元素到第 i 个位置，原后继元素依次后移 | $O(n)$ |
| `remove(i)` | 删除第 i 个元素，原后继元素依次前移 | $O(n)$ |
| `sort()` | 排序，使元素非降序排列 | 依排序算法而不同 |
| `find(e)` | 顺序查找元素 e | $O(n)$ |
| `search(e)`（有序） | 二分查找元素 e | $O(\log{n})$ |
| `deduplicate()` | 唯一化（去重），从首到末，不断在前缀中查找与当前元素相同者并删除 | $O(n^2)$ |
| `uniquify()`（有序） | 唯一化（去重），两个索引变量不同步向后移动赋值 | $O(n)$ |
| `traverse()` | 遍历向量所有元素 | $O(n)$ |

### 扩容和缩容

需要重新分配存储空间。

#### 扩容

策略：

- 以 2 为比例指数增长
    - 分摊复杂度 $O(1)$
- 以常数为增量线性增长
    - 分摊复杂度 $O(n)$

#### 缩容

除非对空间利用率要求极高，否则没必要。装填因子下限应当较低，否则可能出现频繁交替扩容和缩容的抖动情况。

### 置乱

```cpp
for (int i = V.size(); i > 0; i--) { // 从后往前
    swap(V[i-1], V[rand() % i]; // 将 V[i-1] 与 V[0, i) 中某一元素交换
}
```

### 唯一化（无序）

```cpp
Rank i = 1;
while (i < _size) {
    (find(_elem[i], 0, i) < 0) ? i++ : remove(i); // 从前缀 _elem[0, i) 中寻找相同者并删除
}
```

### 唯一化（有序）

```cpp
for (Rank i = 0, j = 1; j < _size; j++) {
    if (_elem[i] != _elem[j]) {
        _elem[++i] = _elem[j];
    }
}
_size = ++i;
```

### 二分查找

#### 二分查找（版本 A）

```cpp
// 版本 A
while (lo < hi) {
    Rank mi = (lo + hi) / 2;
    if (e < A[mi]) hi = mi; // 向左 [lo, mi)
    else if (A[mi] < e) lo = mi + 1; // 向右 [mi+1, hi)
    else return mi; // 命中
}
return -1;
```

平均查找长度：$O(1.5 \log_2{n})$。

**查找长度**：算法中所执行的元素比较操作次数。（见邓《数据结构》P50 详细说明）

二分查找版本 A 的问题在于，向左深入需要比较一次，向右深入需要比较两次，左右不均衡。改进思路：

- 调整左右区域的宽度，使总体均衡——Fibonacci 查找
- 修改算法细节使深入左右两区域所需的比较次数相同（都等于 1）——二分查找（版本 B、C）

#### Fibonacci 查找

```cpp
Fib fib(hi - lo); // 生成从 1 到 hi-lo 的 Fibonacci 数列
while (lo < hi) {
    while (fib.get() > hi - lo) fib.prev(); // 从后往前找到第一个小于 hi-lo 的 Fibonacci 数
    Rank mi = lo + fib.get() - 1;
    if (e < A[mi]) hi = mi; // 向左
    else if (A[mi] < e) lo = mi + 1; // 向右
    else return mi; // 命中
}
return -1;
```

平均查找长度：$O(1.44 \log_2{n})$。

#### 二分查找（版本 B）

```cpp
while (1 < hi - lo) { // 当 [lo, hi) 中只剩一个元素时停止
    Rank mi = (lo + hi) / 2;
    (e < A[mi]) ? hi = mi : lo = mi; // 向左 [lo, mi) 或向右 [mi, hi)（注意即使 e == A[mi] 也不会停止）
}
return (e == A[lo]) ? lo : -1; // 比较区间中剩的元素是否是要查找的元素
```

由于成功查找后不会停止，故最好情况下效率有所下降，最坏情况效率有所提高。

存在的问题：当向量中有重复元素时，只能“随机”返回其中某个位置，有时会希望能够确定返回重复元素中下标最大的。

#### 二分查找（版本 C）

```cpp
while (lo < hi)
    Rank mi = (lo + hi) / 2;
    (e < A[mi]) ? hi = mi : lo = mi + 1; // 向左 [lo, mi) 或向右 [mi+1, hi)
}
return lo - 1; // 循环结束时，lo 为大于 e 的元素的最小下标，故 lo-1 为不大于 e 的最大下标
```

### 排序

基于比较的排序算法时间复杂度下界：$\Omega(n \log{n})$。

具体排序算法见“排序”单独章节。

## 链表

### 特点

- 存储结构不连续
- 循位置访问（不可随机访问）

### 基本操作

| 操作 | 描述 | 复杂度 |
| --- | --- | --- |
| `get(i)`<br>`put(i, e)` | 通过秩访问节点 | $O(n)$ |
| `first()`<br>`last()` | 获取首、末节点位置（指针） | $O(1)$ |
| `insertAsFirst(e)`<br>`insertAsLast(e)` |将 e 作为首、末节点插入 | $O(1)$ |
| `insertAfter(p, e)`<br>`insertBefore` | 将 e 作为节点 p 的直接后继、前驱插入 | $O(1)$ |
| `remove(p)` | 删除节点 p | $O(1)$ |
| `sort()` | 排序，使元素非降序排列 | 依排序算法而不同 |
| `find(e)` | 顺序查找元素 e，失败时返回 `NULL` | $O(n)$ |
| `search(e)`（有序） | 顺序查找元素 e，返回不大于 e 且秩最大的节点 | $O(n)$ |
| `deduplicate()` | 唯一化（去重），从首到末，不断在前缀中查找与当前元素相同者并删除 | $O(n^2)$ |
| `uniquify()`（有序） | 唯一化（去重），反复考察相邻节点对，删除重复者 | $O(n)$ |
| `traverse()` | 遍历向量所有元素 | $O(n)$ |

### 排序

具体排序算法见“排序”单独章节。

需要注意的是，使用归并排序时，尽管每次划分待排序列表需要 $O(n)$ 的时间，但并不影响最终总的时间复杂度，仍然是 $O(n \log{n})$。
